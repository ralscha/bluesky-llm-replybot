// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queue.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimNextMessage = `-- name: ClaimNextMessage :one
UPDATE message_queue 
SET 
    status = 'processing',
    processing_started_at = NOW()
WHERE id = (
    SELECT id FROM message_queue
    WHERE status = 'pending'
    ORDER BY created_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT 1
)
RETURNING id, message_uri, message_cid, author_did, author_handle, message_text, retry_count
`

type ClaimNextMessageRow struct {
	ID           int64  `json:"id"`
	MessageUri   string `json:"message_uri"`
	MessageCid   string `json:"message_cid"`
	AuthorDid    string `json:"author_did"`
	AuthorHandle string `json:"author_handle"`
	MessageText  string `json:"message_text"`
	RetryCount   *int32 `json:"retry_count"`
}

func (q *Queries) ClaimNextMessage(ctx context.Context) (ClaimNextMessageRow, error) {
	row := q.db.QueryRow(ctx, claimNextMessage)
	var i ClaimNextMessageRow
	err := row.Scan(
		&i.ID,
		&i.MessageUri,
		&i.MessageCid,
		&i.AuthorDid,
		&i.AuthorHandle,
		&i.MessageText,
		&i.RetryCount,
	)
	return i, err
}

const deleteMessageFromQueue = `-- name: DeleteMessageFromQueue :exec
DELETE FROM message_queue 
WHERE id = $1
`

func (q *Queries) DeleteMessageFromQueue(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteMessageFromQueue, id)
	return err
}

const getReadyToSendMessages = `-- name: GetReadyToSendMessages :many
SELECT id, message_uri, message_cid, author_did, author_handle, message_text, llm_response, 
       used_google_search_grounding, model_name, created_at, processing_started_at
FROM message_queue
WHERE status = 'ready_to_send'
ORDER BY created_at ASC
LIMIT $1
`

type GetReadyToSendMessagesRow struct {
	ID                        int64              `json:"id"`
	MessageUri                string             `json:"message_uri"`
	MessageCid                string             `json:"message_cid"`
	AuthorDid                 string             `json:"author_did"`
	AuthorHandle              string             `json:"author_handle"`
	MessageText               string             `json:"message_text"`
	LlmResponse               *string            `json:"llm_response"`
	UsedGoogleSearchGrounding *bool              `json:"used_google_search_grounding"`
	ModelName                 *string            `json:"model_name"`
	CreatedAt                 pgtype.Timestamptz `json:"created_at"`
	ProcessingStartedAt       pgtype.Timestamptz `json:"processing_started_at"`
}

func (q *Queries) GetReadyToSendMessages(ctx context.Context, limit int32) ([]GetReadyToSendMessagesRow, error) {
	rows, err := q.db.Query(ctx, getReadyToSendMessages, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetReadyToSendMessagesRow{}
	for rows.Next() {
		var i GetReadyToSendMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageUri,
			&i.MessageCid,
			&i.AuthorDid,
			&i.AuthorHandle,
			&i.MessageText,
			&i.LlmResponse,
			&i.UsedGoogleSearchGrounding,
			&i.ModelName,
			&i.CreatedAt,
			&i.ProcessingStartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStaleProcessingMessages = `-- name: GetStaleProcessingMessages :many
SELECT id, message_uri, message_cid, author_did, author_handle, message_text, retry_count
FROM message_queue
WHERE status = 'processing' 
  AND processing_started_at < NOW() - INTERVAL '5 minutes'
ORDER BY created_at ASC
`

type GetStaleProcessingMessagesRow struct {
	ID           int64  `json:"id"`
	MessageUri   string `json:"message_uri"`
	MessageCid   string `json:"message_cid"`
	AuthorDid    string `json:"author_did"`
	AuthorHandle string `json:"author_handle"`
	MessageText  string `json:"message_text"`
	RetryCount   *int32 `json:"retry_count"`
}

func (q *Queries) GetStaleProcessingMessages(ctx context.Context) ([]GetStaleProcessingMessagesRow, error) {
	rows, err := q.db.Query(ctx, getStaleProcessingMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStaleProcessingMessagesRow{}
	for rows.Next() {
		var i GetStaleProcessingMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageUri,
			&i.MessageCid,
			&i.AuthorDid,
			&i.AuthorHandle,
			&i.MessageText,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMessage = `-- name: InsertMessage :one
INSERT INTO message_queue (
    message_uri,
    message_cid,
    author_did,
    author_handle,
    message_text
) VALUES (
    $1, $2, $3, $4, $5
) 
ON CONFLICT (message_uri) DO NOTHING
RETURNING id
`

type InsertMessageParams struct {
	MessageUri   string `json:"message_uri"`
	MessageCid   string `json:"message_cid"`
	AuthorDid    string `json:"author_did"`
	AuthorHandle string `json:"author_handle"`
	MessageText  string `json:"message_text"`
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertMessage,
		arg.MessageUri,
		arg.MessageCid,
		arg.AuthorDid,
		arg.AuthorHandle,
		arg.MessageText,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const resetStaleMessage = `-- name: ResetStaleMessage :exec
UPDATE message_queue 
SET 
    status = 'pending',
    processing_started_at = NULL,
    retry_count = retry_count + 1
WHERE id = $1
`

func (q *Queries) ResetStaleMessage(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, resetStaleMessage, id)
	return err
}

const updateMessageFailed = `-- name: UpdateMessageFailed :exec
UPDATE message_queue 
SET 
    status = CASE 
        WHEN retry_count + 1 < $2 THEN 'pending'
        ELSE 'failed'
    END,
    retry_count = retry_count + 1,
    error_message = $3,
    processing_started_at = NULL,
    completed_at = CASE 
        WHEN retry_count + 1 >= $2 THEN NOW()
        ELSE NULL
    END
WHERE id = $1
`

type UpdateMessageFailedParams struct {
	ID           int64   `json:"id"`
	RetryCount   *int32  `json:"retry_count"`
	ErrorMessage *string `json:"error_message"`
}

func (q *Queries) UpdateMessageFailed(ctx context.Context, arg UpdateMessageFailedParams) error {
	_, err := q.db.Exec(ctx, updateMessageFailed, arg.ID, arg.RetryCount, arg.ErrorMessage)
	return err
}

const updateMessageWithLLMResponse = `-- name: UpdateMessageWithLLMResponse :exec
UPDATE message_queue 
SET 
    status = 'ready_to_send',
    llm_response = $2,
    used_google_search_grounding = $3,
    model_name = $4,
    retry_count = 0,
    completed_at = NOW()
WHERE id = $1
`

type UpdateMessageWithLLMResponseParams struct {
	ID                        int64   `json:"id"`
	LlmResponse               *string `json:"llm_response"`
	UsedGoogleSearchGrounding *bool   `json:"used_google_search_grounding"`
	ModelName                 *string `json:"model_name"`
}

func (q *Queries) UpdateMessageWithLLMResponse(ctx context.Context, arg UpdateMessageWithLLMResponseParams) error {
	_, err := q.db.Exec(ctx, updateMessageWithLLMResponse,
		arg.ID,
		arg.LlmResponse,
		arg.UsedGoogleSearchGrounding,
		arg.ModelName,
	)
	return err
}
